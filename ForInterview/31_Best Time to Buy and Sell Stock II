给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int sum=0,left=prices[0],right=-1,length=prices.size();
        for(int i=0;i<length-1;){
            while((i<length-1)&&prices[i+1]<=prices[i]){
                left=prices[++i];
            }
            
            while((i<length-1)&&prices[i+1]>=prices[i]){
                right=prices[++i];
            }
            if(right!=-1) sum+=right-left;
            right=-1;

        } 
        return sum;       
    }
};
////////////////////////////优化//////////////////////////////////
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;

        int maxprofit = 0;

        for(int i=1;i<prices.size();++i)
        {
            maxprofit += max(prices[i]-prices[i-1], 0);
        }

        return maxprofit;
    }
};
从贪心算法思路看，就是逢低就买入，逢高就卖出。（记住，贪心算法就是说一个目光短浅的贪心的人，只会考虑下一步的得失，从不考虑长远的利益）
意思就是，只要第i-1天的价格小于第i天的价格（即prices[i] - prices[i-1] > 0），便在第i-1天买入，第i天卖出。
注意，假设 prices[1]=1, prices[2]=2, prices[3]=1000，即便在第一天买入第三天卖出可以获利999，而第一天买入第二天卖出只能获利1，我们也要在第一天买入第二天卖出。这就是贪心算法的思路，始终保持目光短浅，只注重眼前的利益！但这其实不会影响最终结果的，下一点会做出解释。
我们从数学的角度来看，其实第三点的思路有点类似我们高中学的“裂项相消法”的“相消”部分。假设 prices = [1,2,3,4,1000]，我们知道答案是返回999，即在第一天买入，第四天卖出获利最大。但是如果我们用贪心算法，则会有：
第一天：无获利，获利0
第一天买入，第二天卖出：2-1 = 1，获利0+1=1
第二天买入，第三天卖出：3-2 = 1，获利1+1=2
第三天买入，第四天卖出：4-3=1，获利2+1=3
第四天买入，第五天卖出：1000-4=996，获利3+996=999，与第一天买入，第四天卖出所获得的利益是一样的，是不是很神奇？
其实把它们合起来，就是“相消”的写法：0+(2-1)+(3-2)+(4-3)+(1000-4)=0+2-1+3-2+4-3+1000-4=0-1+1000=999。现在理解贪心算法了吧？这是一个贪心但不笨的人～
